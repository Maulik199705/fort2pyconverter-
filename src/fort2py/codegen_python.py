from __future__ import annotations
from pathlib import Path
from typing import List, Tuple

from .ir import ProjectIR, Module, Subroutine, Function, Argument, VarDecl
from .types import DTYPE_MAP, as_fortran_array
from .utils import write_text


HEADER = """# Auto-generated by fort2py. Deterministic and explicit; do not edit manually.
import math
import numpy as np

from fort2py.types import Ref
from fort2py.intrinsics import *
"""


def _py_type_for(v: VarDecl) -> str:
    if v.type_spec == "real":
        dt = DTYPE_MAP.real_from_kind(v.kind)
        return f"np.{dt.name}"
    if v.type_spec == "integer":
        dt = DTYPE_MAP.int_from_kind(v.kind)
        return f"np.{dt.name}"
    if v.type_spec == "logical":
        return "bool"
    if v.type_spec == "character":
        return "str"
    raise NotImplementedError(f"Unsupported type: {v.type_spec}")


def _default_value_for(v: VarDecl) -> str:
    if v.type_spec == "real":
        return "0.0"
    if v.type_spec == "integer":
        return "0"
    if v.type_spec == "logical":
        return "False"
    if v.type_spec == "character":
        return "''"
    return "None"


def _emit_args(args: List[Argument]) -> Tuple[str, List[str]]:
    # Build Python signature with optional default None to mimic Fortran OPTIONAL
    parts = []
    prelude: List[str] = []
    for a in args:
        nm = a.name
        default = "None" if a.optional else None
        if default is None:
            parts.append(nm)
        else:
            parts.append(f"{nm}=None")
        if a.optional:
            prelude.append(f"    # OPTIONAL argument: {nm}")
        if a.byref:
            prelude.append(f"    assert isinstance({nm}, Ref), 'Argument {nm} must be Ref(...) for OUT/INOUT scalar'")
    return ", ".join(parts), prelude


def _emit_decl_init(v: VarDecl) -> str:
    # For local vars with SAVE or allocatable defaults, we create local initialization at entry.
    if v.dims:
        dt = _py_type_for(v)
        shape = ", ".join(str(d) for d in v.dims)
        return f"    {v.name} = np.zeros(({shape},), dtype={dt}, order='F')"
    else:
        return f"    {v.name} = {_default_value_for(v)}"


def _translate_exec_line(line: str) -> str:
    # Very conservative MVP translation; raise on unsupported constructs.
    s = line.strip()
    if not s:
        return ""
    # Assignment
    if "=" in s and not s.lower().startswith("if"):
        # Basic transform; full expression parser is out-of-scope for MVP
        # Replace Fortran .and., .or., .not., .eq., .ne., .lt., .le., .gt., .ge.
        py = (
            s.replace(".and.", " and ")
            .replace(".or.", " or ")
            .replace(".not.", " not ")
            .replace(".eq.", "==")
            .replace(".ne.", "!=")
            .replace(".lt.", "<")
            .replace(".le.", "<=")
            .replace(".gt.", ">")
            .replace(".ge.", ">=")
        )
        # Array indexing: Fortran 1-based to Python 0-based adjustment is complex.
        # MVP leaves indices as-is and documents requirement to ensure translations handle i-1 externally.
        return f"    {py}"
    # IF ... THEN single-line (no else)
    if s.lower().startswith("if") and "then" in s.lower():
        cond = s[s.find("(") + 1 : s.rfind(")")]
        return f"    if {cond}:"
    if s.lower().startswith("end if"):
        return ""
    if s.lower().startswith("do "):
        # Handle "do i=1,n"
        body = s[3:].strip()
        if "=" in body:
            var, rng = body.split("=", 1)
            var = var.strip()
            a, b = [t.strip() for t in rng.split(",")[:2]]
            # Fortran inclusive range and 1-based; Python range is exclusive end
            return f"    for {var} in range({a}-1, {b}):"
        raise NotImplementedError(f"Unsupported DO form: {s}")
    if s.lower().startswith("end do"):
        return ""
    if s.lower().startswith("call "):
        call = s[5:].strip()
        return f"    {call}"
    # Printing / I/O placeholders: raise to avoid silent format loss
    if s.lower().startswith(("print", "write", "read", "open", "close", "rewind", "format")):
        raise NotImplementedError(f"I/O translation requires format handling; not supported in MVP: {s}")
    # Select case, where, forall, etc. are out of MVP
    raise NotImplementedError(f"Unsupported executable statement in MVP: {s}")


def generate_module(mod: Module) -> str:
    out = [HEADER]
    out.append(f"# Module: {mod.name}")
    for sub in mod.subroutines:
        sig, prelude = _emit_args(sub.args)
        out.append(f"def {sub.name}({sig}):")
        if prelude:
            out.extend(prelude)
        # Locals init
        for d in sub.declarations:
            out.append(_emit_decl_init(d))
        # Body
        for line in sub.body:
            out.append(_translate_exec_line(line))
        out.append("")  # blank line

    for fun in mod.functions:
        sig, prelude = _emit_args(fun.args)
        out.append(f"def {fun.name}({sig}):")
        if prelude:
            out.extend(prelude)
        for d in fun.declarations:
            out.append(_emit_decl_init(d))
        for line in fun.body:
            out.append(_translate_exec_line(line))
        # Return value handling (MVP expects return var assigned)
        out.append(f"    return {fun.return_name}")
        out.append("")

    return "\n".join(out)


def write_project_python(ir: ProjectIR, out_dir: Path) -> List[Path]:
    written: List[Path] = []
    for mod in ir.modules.values():
        code = generate_module(mod)
        p = out_dir / f"{mod.name.lower()}.py"
        write_text(p, code)
        written.append(p)
    return written
